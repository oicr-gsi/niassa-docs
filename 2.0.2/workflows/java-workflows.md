---
layout: page
title: Java Workflows
nav: false
---
{% include functions.liquid %}

This document describes the format of the Niassa API for writing Java workflows. 
For more information about the entire workflow bundle, including generating a 
functional workflow bundle with Maven archetypes, please see 
[Workflow Bundle]({{version_url}}/workflows/workflow-bundles).

## Getting Niassa Pipeline API in your Maven project

We use Maven 3. All dependencies are available from the OICR Artifactory instance. The [gsi-config](https://github.com/oicr-gsi/gsi-config) Github repository contains the definitive `settings.xml` file, as well as a README with more details.

1. Download: https://raw.githubusercontent.com/oicr-gsi/gsi-config/master/settings.xml
2. Copy to: `~/.m2/settings.xml`

Then, in your `pom.xml` file:

```xml
<dependency>
    <groupId>com.github.seqware</groupId>
    <artifactId>seqware-pipeline</artifactId>
    <version>{{ version }}</version>
</dependency>
<dependency>
    <groupId>com.github.seqware</groupId>
    <artifactId>seqware-common</artifactId>
    <version>{{ version }}</version>
</dependency>
<dependency>
    <groupId>com.github.seqware</groupId>
    <artifactId>seqware-distribution</artifactId>
    <version>{{ version }}</version>
    <classifier>full</classifier>
</dependency>
<dependency>
    <groupId>com.github.seqware</groupId>
    <artifactId>seqware-meta-db</artifactId>
    <version>{{ version }}</version>
</dependency>
<dependency>
    <groupId>com.github.seqware</groupId>
    <artifactId>seqware-webservice</artifactId>
    <version>{{ version }}</version>
    <type>war</type>
</dependency>
```

We recommend beginning from workflow bundle generated by a Maven archetype 
rather than rolling your own workflow project. Tips on using 
archetypes are available in 
[Workflow Bundle]({{version_url}}/workflows/workflow-bundles).

## A Tour of the Java Workflow Syntax

This Java class used to define
input and output files along with the individual steps in the workflow and how
they relate to each other.  It is used to create a workflow object model which
is then handed of to a workflow engine that knows how to turn that into a
directed acyclic graph of jobs that can run on a cluster (local VM, an HPC
cluster, a cloud-based cluster, etc).

The full contents of the `MyHelloWorldWorkflow.java` are included below. We will 
describe each section in more detail next:

{% include_relative snippets/workflow-full.md %}

### Variables

Variables are defined as any other object variables would be in Java. To
access variables from the workflow's ini file use the
`getProperty("key")` method.

{% include_relative snippets/variables.md %}

### Files & Directories

Files that are inputs or outputs from workflows need to be copied in or out
respectively.  Under the hood, this uses the ProvisionFiles module that knows
how to move around local files, files over HTTP, or remote files on Amazon's
S3. The Java syntax simplifies the declaration of these input and output files
for workflows by providing the method below. Keep in mind, you can also just
transfer input or output files by using a standard job that calls the necessary
command line tool and bypass this built in system. But the
`setupFiles()` method will likely work for most purposes and is the
easiest way to register workflow files.

{% include_relative snippets/setupFiles.md %}

Output files are linked to the jobs that produce those files with 
`addFile(SqwFile)`. A convenience method is provided in the archetype for 
creating output files. Note that these files are not available from 
`this.getFiles().get(String)`.

{% include_relative snippets/output-files.md %}

You can also specify directories to be created in the working directory of your 
workflow.

{% include_relative snippets/setupDirectory.md %}

### Jobs & Dependencies

Jobs are created using the `Job` object in the Niassa SDK. Jobs have a number of
available methods that can be configured. The command for the Job is set using the 
`getCommand()` and `setCommand(String)` methods. You can use any command that can be 
executed in a Bash shell. 

{% include_relative snippets/add-jobs.md %}

The `addParent` command links together jobs that have dependencies on each 
other. A child job will not begin executing until its parent is complete (and 
successful).

### Other methods available for jobs

Because reading source is fun, here! [Job](https://github.com/oicr-gsi/niassa/blob/develop/seqware-pipeline/src/main/java/net/sourceforge/seqware/pipeline/workflowV2/model/Job.java)

TODO: make a nice table.


## Symbolic Links to Local Dependencies

This type of dependency is not generally recommended. In most cases you will want to 
check a dependency into a Maven repository or add it into the binary or data 
directories of a workflow. 

However, in the following cases, you will need to rely on symbolic links:

*   The dependency is too large to go into a maven repository 
*   The dependency is proprietary or cannot be redistributed 

By convention, the symlinks go into a directory in the root of the workflow called 
`links`. They should link to a directory, not to a single file (for the purposes of 
copying the dependencies to the final bundle. Maven doesn't accept single files for 
copying upon install. The SeqWare archeype for Java workflow symlinks the entire `links` folder to the `data` directory in the final workflow bundle.


First, create the link:

```
[seqware@seqwarevm workflow-MyHelloWorld]$ cd links
[seqware@seqwarevm links]$ rm -Rf *
[seqware@seqwarevm links]$ ln -s ../workflow/data/
[seqware@seqwarevm links]$ ls -alhtr
total 8.0K
drwxrwxr-x 5 seqware seqware 4.0K May 31 17:39 ..
lrwxrwxrwx 1 seqware seqware   17 May 31 17:41 data -> ../workflow/data/
drwxrwxr-x 2 seqware seqware 4.0K May 31 17:41 .
```

Second, check your bundle's pom.xml to verify that the maven-junction-plugin is 
present. This plugin will create a link when compiling your bundle:

```xml	
<build>
   ...
    <plugins>
 ...
        <plugin>
            <groupId>com.pyx4j</groupId>
            <artifactId>maven-junction-plugin</artifactId>
            <executions>
                    <execution>
                    <phase>package</phase>
                    <goals>
                            <goal>link</goal>
                    </goals>
            </execution>
            <execution>
                    <id>unlink</id>
                    <phase>clean</phase>
                    <goals>
                            <goal>unlink</goal>
                    </goals>
          </execution>
        </executions>
        <configuration>
          <links>
           <link>
              <dst>${project.build.directory}/Workflow_Bundle_${workflow-name}_${project.version}_SeqWare_{{ version }}/Workflow_Bundle_${workflow-directory-name}/${project.version}/data/data</dst>
              <src>${basedir}/links/data</src>
            </link>
          </links>
        </configuration>
     </plugin>
    </plugins>
</build>
```

Your bundles will now contain a symbolic link to your dependency after "mvn clean 
install" in the data directory and this will only be included in the bundle when the 
bundle is packaged (and/or installed). Note that the destination directory cannot 
exist before the junction occurs or it will fail.

## Running the Workflow

You can run the Workflow using the test process shown in the [Developer Tutorial]({{version_url}}/getting-started-developer-tutorial).

